#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# vars
OVERWRITE="\e[1A\e[K"
INFO=" \033[1;34m\033[0m "
DONE=" \033[0;32m\033[0m "
ERROR=" \033[0;31m\033[0m "
WARNING=" \033[1;33m\033[0m "
ADD=" \033[0;34m\033[0m "
COMMIT=" \033[1;35m\033[0m "

# request user input to decide whether to push or not
get_input() {
    exec </dev/tty # open STDIN to read input

    # read user input
    while true; do
        # `read -p` doesn't support standard formatting. Use `$'...'` instead
        read -p $' \033[1;36m\033[0m  Do you wish to commit and push automagically? (Y/n) ' yn

        # accept blank input as "yes"
        if [ "$yn" = "" ]; then
            yn="Y"
        fi

        # check input
        case "$yn" in
        [Yy])
            return 0
            ;;
        [Nn])
            return 1
            ;;
        *)
            printf "Please answer with \"Y\" or \"N\"."
            ;;
        esac
    done

    exec <&- # close STDIN
}

# check if user wants to track and commit changes automatically, then
# either exits (1) or commits (0)
function commit() {
    to_track=$(get_input)
    directory=$1

    # Exiting is kind of an exception, so we check for it first
    if [ $to_track -eq 1 ]; then
        printf "${ERROR} Exiting\n"
        return 1
    fi

    # it's assumed that the user wants to commit and push automatically
    printf "${ADD} Tracking changes...\n" &&
        git add ./$directory

    printf "${COMMIT} Committing changes\n" &&
        git commit -m "feat($directory): :robot:  update \`./$directory\`"
    return
}

# given a directory/file it will check if it has been modified since the last
# commit. If it has, it will invoke commit()
function diff() {
    directory="\e[1;34;1;40m./$1\e[0m"

    printf "\n${INFO} Checking for changes in ${directory}\n"

    # check if given directory has been updated
    if git diff --quiet --exit-code -- ./$1/*; then
        printf "${DONE} No changes to ${directory}\n"
        return
    fi

    printf "${WARNING} Changes in ${directory}\n" &&
        commit $1
    return
}

# generates a changelog based on the commits since the last tag. track and
# commit changes only if file contents have been modified
function changelog() {
    changelog="\e[1;34;1;40m./CHANGELOG.md\e[0m"
    # generate changelog first
    printf "\n${INFO} Generating changelog\n" &&
        git-cliff --config ./cliff.toml --output ./CHANGELOG.md

    diff "CHANGELOG.md"

    return
}

# generate automatically a changelog
# generate_changelog() {
#     printf "\n${INFO} Generating changelog...\n"
#     git-cliff.exe --output ./CHANGELOG.md

#     # track and commit changes
#     printf "${ADD} Tracking changes...\n"
#     git add ./CHANGELOG.md

#     printf "${COMMIT} Committing changes...\n"
#     git commit -m "docs(changelog) :robot:  update \`./CHANGELOG.md\`"

#     return
# }

# check if user can push

main() {
    # # check_diff
    # diff ".vscode"
    # generate_changelog
    # # can_push

    diff ".vscode"
    changelog
}

main
